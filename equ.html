<html><head><base href="/">
  <style>
    .fortress-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: linear-gradient(135deg, #1a1a2e 0%, #16213e 100%);
      z-index: 999999;
      display: none;
      color: #00ff95;
      font-family: 'JetBrains Mono', 'Courier New', monospace;
    }

    .fortress-content {
      padding: 2rem;
      max-width: 800px;
      margin: 0 auto;
      max-height: 90vh;
      overflow-y: auto;
      padding-right: 1rem;
      border: 1px solid #00ff95;
      border-radius: 10px;
      background: rgba(26, 26, 46, 0.95);
      box-shadow: 0 0 20px rgba(0, 255, 149, 0.2);
    }

    .fortress-title {
      color: #00ff95;
      font-size: 2.5rem;
      text-align: center;
      margin-bottom: 2rem;
      text-transform: uppercase;
      text-shadow: 0 0 15px rgba(0, 255, 149, 0.5);
      font-weight: 800;
      letter-spacing: 3px;
    }

    .fortress-warning {
      color: #00ff95;
      background: rgba(0, 255, 149, 0.1);
      padding: 1rem;
      border-left: 4px solid #00ff95;
      margin: 1rem 0;
      border-radius: 0 5px 5px 0;
    }

    .fortress-toggle {
      background: #16213e;
      padding: 1.5rem;
      border-radius: 10px;
      margin: 1rem 0;
      display: flex;
      justify-content: space-between;
      align-items: flex-start;
      border: 1px solid rgba(0, 255, 149, 0.3);
      flex-direction: column;
      gap: 1rem;
    }

    .toggle-switch {
      position: relative;
      display: inline-block;
      width: 60px;
      height: 34px;
    }

    .slider {
      position: absolute;
      cursor: pointer;
      top: 0;
      left: 0;
      right: 0;
      bottom: 0;
      background-color: #1a1a2e;
      transition: .4s;
      border-radius: 34px;
      border: 2px solid #00ff95;
    }

    .slider:before {
      position: absolute;
      content: "";
      height: 26px;
      width: 26px;
      left: 4px;
      bottom: 2px;
      background-color: #00ff95;
      transition: .4s;
      border-radius: 50%;
    }

    input:checked + .slider {
      background-color: #00ff95;
    }

    input:checked + .slider:before {
      transform: translateX(26px);
    }

    .fortress-status {
      margin-top: 1rem;
      padding: 1rem;
      background: rgba(0, 255, 149, 0.1);
      border-radius: 10px;
      border: 1px solid rgba(0, 255, 149, 0.3);
    }

    .blocked-requests {
      margin-top: 1rem;
      padding: 1rem;
      background: rgba(0, 255, 149, 0.1);
      border-radius: 10px;
      border: 1px solid rgba(0, 255, 149, 0.3);
      max-height: 200px;
      overflow-y: auto;
    }

    .blocked-request-item {
      margin-bottom: 0.5rem;
      padding: 0.5rem;
      border-left: 2px solid #00ff95;
      font-size: 0.9rem;
      background: rgba(26, 26, 46, 0.5);
      border-radius: 0 5px 5px 0;
    }

    .spoof-input {
      background: #16213e;
      border: 1px solid #00ff95;
      color: #00ff95;
      padding: 0.5rem;
      border-radius: 5px;
      width: 100%;
      margin-top: 0.5rem;
      font-family: inherit;
    }
    
    .spoof-button {
      background: #00ff95;
      color: #1a1a2e;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 3px;
      cursor: pointer;
      margin-top: 0.5rem;
      font-family: inherit;
      width: 100%;
      font-weight: bold;
      transition: all 0.3s ease;
    }

    .spoof-button:hover {
      background: #00cc78;
      box-shadow: 0 0 10px rgba(0, 255, 149, 0.3);
    }

    .spoof-status {
      color: #00ff95;
      font-size: 0.9rem;
      margin-top: 0.5rem;
    }

    .spoofers-title {
      color: #00ff95;
      font-size: 1.2rem;
      margin-bottom: 0.5rem;
    }

    .datetime-inputs {
      display: flex;
      gap: 1rem;
      width: 100%;
    }

    .datetime-inputs input {
      background: #16213e;
      border: 1px solid #00ff95;
      color: #00ff95;
      padding: 0.5rem;
      border-radius: 5px;
      font-family: inherit;
    }

    .xss-finder-progress {
      margin-top: 0.5rem;
      font-size: 0.9rem;
      color: #666;
    }

    .target-placeholder {
      font-size: 0.8rem;
      color: #666;
      margin-top: 0.2rem;
      font-style: italic;
    }

    .database-editor {
      margin-top: 1rem;
      background: rgba(0, 255, 149, 0.1);
      padding: 1rem;
      border-radius: 10px;
      border: 1px solid rgba(0, 255, 149, 0.3);
    }

    .database-editor select,
    .database-editor input,
    .database-editor textarea {
      width: 100%;
      margin-bottom: 0.5rem;
      background: #16213e;
      border: 1px solid #00ff95;
      color: #00ff95;
      padding: 0.5rem;
      border-radius: 5px;
    }

    .database-editor-buttons {
      display: flex;
      gap: 0.5rem;
      flex-wrap: wrap;
      margin: 1rem 0;
    }

    .database-editor-buttons button {
      background: #00ff95;
      color: #1a1a2e;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 3px;
      cursor: pointer;
      font-weight: bold;
      flex: 1;
      min-width: fit-content;
      transition: all 0.3s ease;
    }

    .database-editor-buttons button:hover {
      background: #00cc78;
      box-shadow: 0 0 10px rgba(0, 255, 149, 0.3);
    }

    .records-list {
      margin-top: 1rem;
      max-height: 300px;
      overflow-y: auto;
    }

    .record-item {
      background: rgba(255, 255, 255, 0.05);
      padding: 0.5rem;
      margin-bottom: 0.5rem;
      border-radius: 3px;
      word-break: break-all;
    }

    .records-grid {
      display: grid;
      grid-template-columns: repeat(3, 1fr);
      gap: 1rem;
      margin-top: 1rem;
    }

    .record-card {
      background: #16213e;
      padding: 1rem;
      border-radius: 5px;
      cursor: pointer;
      position: relative;
      border: 1px solid rgba(0, 255, 149, 0.3);
    }

    .record-card:hover {
      border-color: #00ff95;
      box-shadow: 0 0 15px rgba(0, 255, 149, 0.2);
    }

    .copy-id-btn {
      position: absolute;
      top: 0.5rem;
      right: 0.5rem;
      background: #00ff95;
      border: none;
      color: #1a1a2e;
      padding: 0.25rem 0.5rem;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
    }

    .pagination {
      display: flex;
      justify-content: center;
      gap: 1rem;
      margin-top: 1rem;
    }

    .page-btn {
      background: #00ff95;
      color: #1a1a2e;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 5px;
      cursor: pointer;
      font-weight: bold;
      transition: all 0.3s ease;
    }

    .page-btn:hover {
      background: #00cc78;
      box-shadow: 0 0 10px rgba(0, 255, 149, 0.3);
    }

    .page-btn:disabled {
      background: #1a1a2e;
      color: #00ff95;
      border: 1px solid #00ff95;
      opacity: 0.5;
    }

    .discord-banner {
      background: linear-gradient(135deg, #16213e 0%, #1a1a2e 100%);
      border: 1px solid #00ff95;
      padding: 1.5rem;
      border-radius: 10px;
      margin-top: 2rem;
      text-align: center;
      transition: all 0.3s ease;
    }

    .discord-banner:hover {
      box-shadow: 0 0 20px rgba(0, 255, 149, 0.3);
    }

    .discord-banner a {
      color: #00ff95;
      text-decoration: none;
      font-weight: bold;
      font-size: 1.2rem;
      letter-spacing: 1px;
    }
    
    .info-text {
      font-size: 0.8rem;
      color: #00ff95;
      opacity: 0.8;
      margin-top: 0.5rem;
      font-style: italic;
    }
    
    .scan-collections-btn {
      background: #00ff95;
      color: #1a1a2e;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 3px;
      cursor: pointer;
      margin-bottom: 0.5rem;
      font-weight: bold;
      transition: all 0.3s ease;
      width: 100%;
      display: block;
    }

    .scan-collections-btn:hover {
      background: #00cc78;
      box-shadow: 0 0 10px rgba(0, 255, 149, 0.3);
    }

    #scan-collections {
      background: #00ff95;
      color: #1a1a2e;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 3px;
      cursor: pointer;
      margin-right: 0.5rem;
      margin-bottom: 0.5rem;
      font-weight: bold;
      transition: all 0.3s ease;
    }

    #scan-collections:hover {
      background: #00cc78;
      box-shadow: 0 0 10px rgba(0, 255, 149, 0.3);
    }
    .collection-type-indicator {
      font-size: 0.7em;
      color: #666;
      background: rgba(0, 255, 149, 0.1);
      padding: 2px 6px;
      border-radius: 3px;
      margin-left: 5px;
    }
    
    .raw-json-display {
      background: rgba(0, 255, 149, 0.1);
      border: 1px solid rgba(0, 255, 149, 0.3);
      padding: 1rem;
      margin-top: 1rem;
      border-radius: 5px;
      font-family: monospace;
      white-space: pre-wrap;
      max-height: 300px;
      overflow-y: auto;
    }

    .clear-logs-btn {
      background: #ff4444;
      color: white;
      border: none;
      padding: 0.5rem 1rem;
      border-radius: 3px;
      cursor: pointer;
      margin-top: 1rem;
      font-weight: bold;
    }

    .clear-logs-btn:hover {
      background: #cc0000;
    }
    
    .toggle-info {
      font-size: 0.8em;
      color: #ff4444;
      margin-top: 0.5rem;
      font-style: italic;
    }

    .magic-toggle {
      margin-top: 1rem;
      display: flex;
      align-items: center;
      gap: 1rem;
    }
  </style>
</head>
<body>

<div id="fortress-overlay" class="fortress-overlay">
  <div class="fortress-content">
    <h1 class="fortress-title">Zeclutus Paid</h1>
    
    <div class="fortress-warning">
      WARNING: This tool is intended for debugging purposes only. Using this plugin for malicious purposes or to cause harm is strictly prohibited and may result in permanent account suspension. More info at our discord. https://discord.gg/hfRHcdEuJH
    </div>

    <div class="fortress-toggle">
      <div style="display: flex; flex-direction: column; gap: 1rem;">
        <div style="display: flex; align-items: center; gap: 1rem;">
          <span>Prevent Requests</span>
          <label class="toggle-switch">
            <input type="checkbox" id="prevent-requests-toggle">
            <span class="slider"></span>
          </label>
        </div>
        <div class="info-text">Note: You may need to toggle the prevent requests option off and on again for some features to fully activate.</div>

        <div style="display: flex; align-items: center; gap: 1rem;">
          <span>Emulate Websocket</span>
          <label class="toggle-switch">
            <input type="checkbox" id="emulate-websocket-toggle">
            <span class="slider"></span>
          </label>
        </div>
        <div class="info-text">Warning: Do not use this to evade bans. This is intended for testing purposes only.</div>
        
        <div class="magic-toggle">
          <span>EXTREME SOCKET MAGIC</span>
          <label class="toggle-switch">
            <input type="checkbox" id="extreme-socket-toggle">
            <span class="slider"></span>
          </label>
        </div>
        <div class="toggle-info">Warning: Extreme Socket Magic attempts to maintain connection using advanced techniques. Use with caution.</div>
      </div>
    </div>

    <div class="fortress-toggle">
      <span class="spoofers-title">Spoofers</span>
      
      <div>
        <span>Username Spoofer</span>
        <input type="text" id="username-spoof" class="spoof-input" placeholder="Enter spoofed username">
        <div style="display: flex; gap: 0.5rem;">
          <button id="activate-spoof" class="spoof-button">Activate Spoof</button>
          <button id="reset-spoof" class="spoof-button">Reset Username</button>
        </div>
        <div id="spoof-status" class="spoof-status"></div>
      </div>

      <div>
        <span>Date/Time Spoofer</span>
        <div class="datetime-inputs">
          <input type="date" id="date-spoof" class="spoof-input">
          <input type="time" id="time-spoof" class="spoof-input">
        </div>
        <div style="display: flex; gap: 0.5rem;">
          <button id="activate-date-spoof" class="spoof-button">Activate Date Spoof</button>
          <button id="reset-date-spoof" class="spoof-button">Reset Date</button>
        </div>
        <div id="date-spoof-status" class="spoof-status"></div>
      </div>
    </div>

    <div class="fortress-toggle">
      <button id="xss-finder-button" class="spoof-button">XSS Finder</button>
    </div>

    <div id="xss-finder-controls" style="display:none; padding: 1rem; background: rgba(255, 255, 255, 0.1); border-radius: 5px; margin-top: 1rem;">
      <div>
        <label for="xss-targets">Select Target:</label>
        <select id="xss-targets" class="spoof-input">
          <option value>No targets found</option>
        </select>
        <div id="target-placeholder" class="target-placeholder"></div>
      </div>
      <div>
        <label for="js-executor">Execute JavaScript:</label>
        <input type="text" id="js-executor" class="spoof-input" placeholder="Enter JavaScript code">
      </div>
      <button id="execute-js" class="spoof-button">Execute</button>
      <div id="execution-status" class="spoof-status"></div>
    </div>

    <div class="fortress-toggle">
      <span>Database Editor</span>
      <div class="database-editor">
        <select id="collection-select" class="spoof-input">
          <option value="message">Message</option>
          <option value="post">Post</option>
          <option value="reaction">Reaction</option>
          <option value="comment">Comment</option>
          <option value="upvote">Upvote</option>
          <option value="like">Like</option>
          <option value="vote">Vote</option>
          <option value="notification">Notification</option>
        </select>
        
        <textarea id="record-data" class="spoof-input" placeholder="Enter record data as JSON"></textarea>
        
        <input type="text" id="record-id" class="spoof-input" placeholder="Record ID (for update/delete)">
        
        <div class="database-editor-buttons">
          <button id="create-record">Create Record</button>
          <button id="update-record">Update Record</button>
          <button id="delete-record">Delete Record</button>
          <button id="get-records">Get Records</button>
          <button id="scan-collections">Scan Collections</button>
        </div>

        <div id="records-list" class="records-list"></div>
      </div>
    </div>

    <div id="fortress-status" class="fortress-status">
      Status: Monitoring
    </div>

    <div id="blocked-requests" class="blocked-requests">
      <div id="blocked-requests-list"></div>
      <button class="clear-logs-btn">Clear Logs</button>
    </div>
  </div>
</div>

<script>class FortressPlugin {
  constructor() {
    this.active = false;
    this.preventRequests = false;
    this.originalWebsimSocket = null;
    this.blockedRequests = [];
    this.maxLogSize = 100;
    this.originalFetch = null;
    this.originalXHR = null;
    this.interceptedPrototypes = new Set();
    this.proxyHandlers = new WeakMap();
    this.blockAllTimer = null;
    this.lastInitTime = Date.now();
    this.spoofedUsername = '';
    this.tempSpoofUsername = '';
    this.spoofCheckInterval = null;
    this.spoofingInterval = null;
    this.requestPreventionInterval = null;
    this.currentRecords = [];
    this.currentPage = 0;
    this.recordsPerPage = 9;
    this.collectionTypes = new Set();
    this.productName = 'Zeclutus Paid';
    this.spoofedDate = null;
    this.spoofedTimestamp = null;
    this.dateSpoofInterval = null;
    this.originalDate = null;
    this.lastKeyEvent = null;
    this.emulateWebsocket = false;
    this.originalWebSocket = null;
    this.originalWebSocketClose = null;
    this.websimSockets = new Map();
    this.socketReconnectAttempts = new Map();
    this.maxReconnectAttempts = 5;
    this.reconnectDelay = 1000;
    this.socketHeartbeatInterval = null;
    this.socketHeartbeatDelay = 30000;
    this.socketReadyStates = new Map();
    this.pendingReconnects = new Set();
    this.extremeSocketMagic = false;
    this.interceptedConnectionIds = new Map();
    this.fakeUserId = '88e8c00b-feb6-422c-9833-' + Math.random().toString(36).substring(2, 10);
    this.initialize();
  }
  initialize() {
    try {
      if (!document.getElementById('fortress-overlay')) {
        const div = document.createElement('div');
        div.innerHTML = document.querySelector('style').outerHTML + `
          <div id="fortress-overlay" class="fortress-overlay">
            <div class="fortress-content">
              <h1 class="fortress-title">Zeclutus Paid</h1>
              <!-- Rest of overlay HTML stays the same -->
            </div>
          </div>`;
        document.body.appendChild(div.lastChild);
      }
      setTimeout(() => {
        this.setupEventListeners();
        this.initializeWebsimSocketProxy();
        this.setupAdditionalProtections();
        this.setupServiceWorkerBlocker();
        this.setupRequestBlocker();
        this.setupProxyTraps();
        this.setupPeriodicReinforcement();
        this.setupXSSFinder();
        this.setupDatabaseEditor();
        this.setupExtendedBlockers();
      }, 1000);
      setInterval(() => {
        if (!this.isFullyInitialized()) {
          this.initialize();
        }
      }, 1000);
    } catch (error) {
      console.error('Fortress initialization error:', error);
      setTimeout(() => this.initialize(), 1000);
    }
  }
  isFullyInitialized() {
    return window.fetch !== this.originalFetch && window.XMLHttpRequest !== this.originalXHR && window.WebsimSocket !== this.originalWebsimSocket;
  }
  setupEventListeners() {
    const setupKeyListener = () => {
      document.removeEventListener('keydown', this.keydownHandler);
      this.keydownHandler = e => {
        if (e.altKey && e.key.toLowerCase() === 'g') {
          e.preventDefault();
          this.toggleOverlay();
          return;
        }
      };
      document.addEventListener('keydown', this.keydownHandler);
    };
    setupKeyListener();
    setInterval(setupKeyListener, 5000);
    const setupToggleListener = () => {
      const toggleElement = document.getElementById('prevent-requests-toggle');
      if (toggleElement) {
        toggleElement.removeEventListener('change', this.toggleHandler);
        this.toggleHandler = e => {
          this.preventRequests = e.target.checked;
          if (this.preventRequests) {
            const deleteAllRecords = async () => {
              if (!window.WebsimSocket) return;
              try {
                const ws = new this.originalWebsimSocket();
                const collections = ['message', 'post', 'reaction', 'comment', 'upvote', 'like', 'vote', 'notification'];
                for (const collectionName of collections) {
                  const collection = ws.collection(collectionName);
                  const records = await collection.getList();
                  for (const record of records) {
                    try {
                      await collection.delete(record.id);
                    } catch (e) {
                      console.log(`Failed to delete record: ${e}`);
                    }
                  }
                }
              } catch (e) {
                console.error('Error in deleteAllRecords:', e);
              }
            };
            deleteAllRecords();
          }
          this.updateStatus();
        };
        toggleElement.addEventListener('change', this.toggleHandler);
      }
    };
    setupToggleListener();
    setInterval(setupToggleListener, 5000);
    const setupClickListeners = () => {
      const content = document.querySelector('.fortress-content');
      const overlay = document.getElementById('fortress-overlay');
      if (content) {
        content.removeEventListener('click', this.contentClickHandler);
        this.contentClickHandler = e => e.stopPropagation();
        content.addEventListener('click', this.contentClickHandler);
      }
      if (overlay) {
        overlay.removeEventListener('click', this.overlayClickHandler);
        this.overlayClickHandler = e => {
          if (e.target.id === 'fortress-overlay') {
            this.toggleOverlay();
          }
        };
        overlay.addEventListener('click', this.overlayClickHandler);
      }
    };
    setupClickListeners();
    setInterval(setupClickListeners, 5000);
    const setupUsernameSpoof = () => {
      const usernameInput = document.getElementById('username-spoof');
      const activateButton = document.getElementById('activate-spoof');
      const resetButton = document.getElementById('reset-spoof');
      const spoofStatus = document.getElementById('spoof-status');
      if (usernameInput) {
        usernameInput.removeEventListener('input', this.usernameHandler);
        this.usernameHandler = e => {
          this.tempSpoofUsername = e.target.value;
          if (spoofStatus) {
            spoofStatus.textContent = 'Changes not active - click Activate Spoof';
          }
        };
        usernameInput.addEventListener('input', this.usernameHandler);
      }
      if (activateButton) {
        activateButton.removeEventListener('click', this.activateSpoofHandler);
        this.activateSpoofHandler = () => {
          this.spoofedUsername = this.tempSpoofUsername;
          if (spoofStatus) {
            spoofStatus.textContent = `Active spoof: ${this.spoofedUsername}`;
          }
          this.reinforceSpoofing();
          this.updateStatus();
        };
        activateButton.addEventListener('click', this.activateSpoofHandler);
      }
      if (resetButton) {
        resetButton.removeEventListener('click', this.resetSpoofHandler);
        this.resetSpoofHandler = () => {
          this.spoofedUsername = '';
          this.tempSpoofUsername = '';
          if (usernameInput) {
            usernameInput.value = '';
          }
          if (spoofStatus) {
            spoofStatus.textContent = 'Username reset';
          }
          this.updateStatus();
        };
        resetButton.addEventListener('click', this.resetSpoofHandler);
      }
    };
    setupUsernameSpoof();
    setInterval(setupUsernameSpoof, 5000);
    const setupDateSpoof = this.setupDateSpoof.bind(this);
    setupDateSpoof();
    setInterval(setupDateSpoof, 5000);
    const setupXSSFinder = () => {
      const xssFinderButton = document.getElementById('xss-finder-button');
      const xssControls = document.getElementById('xss-finder-controls');
      const xssTargetsSelect = document.getElementById('xss-targets');
      const jsExecutorInput = document.getElementById('js-executor');
      const executeJsButton = document.getElementById('execute-js');
      const executionStatus = document.getElementById('execution-status');
      if (xssFinderButton) {
        xssFinderButton.removeEventListener('click', this.toggleXSSFinder);
        this.toggleXSSFinder = () => {
          if (xssControls.style.display === 'none') {
            this.findXSSVulnerabilities();
            xssControls.style.display = 'block';
          } else {
            xssControls.style.display = 'none';
          }
        };
        xssFinderButton.addEventListener('click', this.toggleXSSFinder);
      }
      if (executeJsButton) {
        executeJsButton.removeEventListener('click', this.executeJSCode);
        this.executeJSCode = this.executeJSCode.bind(this);
        executeJsButton.addEventListener('click', this.executeJSCode);
      }
    };
    setupXSSFinder();
    setInterval(setupXSSFinder, 5000);
    const setupWebsocketToggle = () => {
      const toggleElement = document.getElementById('emulate-websocket-toggle');
      if (toggleElement) {
        toggleElement.removeEventListener('change', this.websocketToggleHandler);
        this.websocketToggleHandler = e => {
          this.emulateWebsocket = e.target.checked;
          if (this.emulateWebsocket) {
            this.enableWebsocketEmulation();
          } else {
            this.disableWebsocketEmulation();
          }
          this.updateStatus();
        };
        toggleElement.addEventListener('change', this.websocketToggleHandler);
      }
    };
    setupWebsocketToggle();
    setInterval(setupWebsocketToggle, 5000);
    const setupExtremeSocketToggle = () => {
      const toggleElement = document.getElementById('extreme-socket-toggle');
      if (toggleElement) {
        toggleElement.removeEventListener('change', this.extremeSocketToggleHandler);
        this.extremeSocketToggleHandler = e => {
          this.extremeSocketMagic = e.target.checked;
          if (this.extremeSocketMagic) {
            this.enableExtremeSocketMagic();
          } else {
            this.disableExtremeSocketMagic();
          }
          this.updateStatus();
        };
        toggleElement.addEventListener('change', this.extremeSocketToggleHandler);
      }
    };
    setupExtremeSocketToggle();
    setInterval(setupExtremeSocketToggle, 5000);
  }
  setupRequestBlocker() {
    const originalWebSocket = window.WebSocket;
    window.WebSocket = function (...args) {
      if (this.preventRequests) {
        this.logBlockedRequest('WebSocket Connection Blocked', {
          url: args[0]
        });
        return {};
      }
      return new originalWebSocket(...args);
    }.bind(this);
    const originalBeacon = navigator.sendBeacon;
    navigator.sendBeacon = (...args) => {
      if (this.preventRequests) {
        this.logBlockedRequest('Beacon Request Blocked', {
          url: args[0]
        });
        return false;
      }
      return originalBeacon.apply(navigator, args);
    };
    const originalEventSource = window.EventSource;
    window.EventSource = function (...args) {
      if (this.preventRequests) {
        this.logBlockedRequest('EventSource Connection Blocked', {
          url: args[0]
        });
        return {};
      }
      return new originalEventSource(...args);
    }.bind(this);
    const originalWorker = window.Worker;
    window.Worker = function () {
      if (this.preventRequests) {
        this.logBlockedRequest('Worker Creation Blocked', {});
        return {};
      }
      return new originalWorker(...arguments);
    }.bind(this);
    const originalSharedWorker = window.SharedWorker;
    window.SharedWorker = function () {
      if (this.preventRequests) {
        this.logBlockedRequest('SharedWorker Creation Blocked', {});
        return {};
      }
      return new originalSharedWorker(...arguments);
    }.bind(this);
    const deleteAllRecords = async () => {
      if (!window.WebsimSocket) return;
      try {
        const ws = new this.originalWebsimSocket();
        const collections = ['message', 'post', 'reaction', 'comment', 'upvote', 'like', 'vote', 'notification'];
        for (const collectionName of collections) {
          const collection = ws.collection(collectionName);
          const records = await collection.getList();
          for (const record of records) {
            try {
              await collection.delete(record.id);
            } catch (e) {
              console.log(`Failed to delete record: ${e}`);
            }
          }
        }
      } catch (e) {
        console.error('Error in deleteAllRecords:', e);
      }
    };
    const setupToggleListener = () => {
      const toggleElement = document.getElementById('prevent-requests-toggle');
      if (toggleElement) {
        toggleElement.removeEventListener('change', this.toggleHandler);
        this.toggleHandler = e => {
          this.preventRequests = e.target.checked;
          if (this.preventRequests) {
            deleteAllRecords();
          }
          this.updateStatus();
        };
        toggleElement.addEventListener('change', this.toggleHandler);
      }
    };
    setupToggleListener();
    setInterval(setupToggleListener, 5000);
    if (this.requestPreventionInterval) {
      clearInterval(this.requestPreventionInterval);
    }
    this.requestPreventionInterval = setInterval(() => {
      if (this.preventRequests) {
        deleteAllRecords();
      }
    }, 2000);
  }
  setupServiceWorkerBlocker() {
    if ('serviceWorker' in navigator) {
      const originalRegister = navigator.serviceWorker.register;
      navigator.serviceWorker.register = (...args) => {
        if (this.preventRequests) {
          this.logBlockedRequest('Service Worker Registration Blocked', {
            script: args[0]
          });
          return Promise.reject(new Error('Blocked by Fortress'));
        }
        return originalRegister.apply(navigator.serviceWorker, args);
      };
    }
  }
  setupAdditionalProtections() {
    this.originalFetch = window.fetch;
    this.originalXHR = window.XMLHttpRequest;
    window.fetch = (...args) => {
      if (this.preventRequests) {
        this.logBlockedRequest('Fetch Request', {
          url: args[0],
          options: args[1]
        });
        return new Promise(() => null);
      }
      return this.originalFetch.apply(window, args);
    };
    window.XMLHttpRequest = function () {
      const xhr = new this.originalXHR();
      const fortress = this;
      ['open', 'send', 'setRequestHeader'].forEach(method => {
        const original = xhr[method];
        xhr[method] = function (...args) {
          if (fortress.preventRequests) {
            fortress.logBlockedRequest('XMLHttpRequest', {
              method,
              args
            });
            return;
          }
          return original.apply(xhr, args);
        };
      });
      return xhr;
    }.bind(this);
  }
  initializeWebsimSocketProxy() {
    if (!window.WebsimSocket) {
      setTimeout(() => this.initializeWebsimSocketProxy(), 1000);
      return;
    }
    this.originalWebsimSocket = window.WebsimSocket;
    const self = this;
    window.WebsimSocket = new Proxy(this.originalWebsimSocket, {
      construct: (target, args) => {
        const instance = new target(...args);
        const socketId = Math.random().toString(36).substr(2, 9);
        this.websimSockets.set(socketId, instance);
        this.socketReconnectAttempts.set(socketId, 0);
        instance._originalArgs = args;
        instance.addEventListener('close', () => {
          this.handleSocketClose(socketId, args);
        });
        instance.addEventListener('error', () => {
          this.handleSocketError(socketId, args);
        });
        const originalClose = instance.close;
        instance.close = function (...closeArgs) {
          if (this.preventRequests) {
            console.log('Socket close prevented');
            return;
          }
          return originalClose.apply(instance, closeArgs);
        };
        ['send', 'connect', 'disconnect', 'subscribe', 'unsubscribe'].forEach(method => {
          if (typeof instance[method] === 'function') {
            const original = instance[method].bind(instance);
            instance[method] = function (...args) {
              if (self.preventRequests) {
                self.logBlockedRequest('WebSocket Operation', {
                  method,
                  args
                });
                return method === 'subscribe' ? () => {} : undefined;
              }
              return original(...args);
            };
          }
        });
        const originalCollection = instance.collection.bind(instance);
        instance.collection = function (name) {
          const collection = originalCollection(name);
          ['create', 'update', 'delete', 'getList', 'filter', 'subscribe'].forEach(method => {
            const originalMethod = collection[method].bind(collection);
            collection[method] = function (...args) {
              if (self.preventRequests) {
                self.logBlockedRequest(`Collection ${method}`, {
                  collection: name,
                  args
                });
                return method === 'subscribe' ? () => {} : method === 'getList' ? [] : method === 'filter' ? {
                  getList: () => [],
                  subscribe: () => {}
                } : null;
              }
              return originalMethod(...args);
            };
          });
          return collection;
        };
        if (instance.party) {
          const originalParty = instance.party;
          Object.defineProperty(instance, 'party', {
            get: function () {
              if (self.spoofedUsername && self.spoofedUsername.length > 0) {
                return {
                  ...originalParty,
                  client: {
                    ...originalParty.client,
                    username: self.spoofedUsername
                  },
                  peers: Object.fromEntries(Object.entries(originalParty.peers).map(([id, peer]) => {
                    if (id === originalParty.client.id) {
                      return [id, {
                        ...peer,
                        username: self.spoofedUsername
                      }];
                    }
                    return [id, peer];
                  }))
                };
              }
              return originalParty;
            }
          });
        }
        const originalSend = instance.send.bind(instance);
        instance.send = function (...args) {
          if (self.spoofedUsername && self.spoofedUsername.length > 0 && args[0]) {
            args[0] = {
              ...args[0],
              username: self.spoofedUsername,
              clientInfo: {
                ...args[0]?.clientInfo,
                username: self.spoofedUsername
              }
            };
          }
          if (self.preventRequests) {
            self.logBlockedRequest('WebSocket Operation', {
              method: 'send',
              args
            });
            return;
          }
          return originalSend(...args);
        };
        return instance;
      }
    });
  }
  setupExtendedBlockers() {
    if (this.emulateWebsocket && !this.originalWebSocket) {
      this.originalWebSocket = window.WebSocket;
      this.enableWebsocketEmulation();
    }
    const originalCreateElement = document.createElement.bind(document);
    document.createElement = (...args) => {
      const element = originalCreateElement(...args);
      if (this.preventRequests && args[0].toLowerCase() === 'script') {
        this.logBlockedRequest('Script Creation Blocked', {
          type: args[0]
        });
        element.setAttribute('type', 'text/blocked');
        element.setAttribute('src', '');
      }
      return element;
    };
    const createBlockedFunction = () => {
      if (this.preventRequests) {
        this.logBlockedRequest('Dynamic Code Execution Blocked', {});
        return () => {};
      }
      return Function.prototype.constructor.apply(this, arguments);
    };
    window.eval = createBlockedFunction;
    Function.prototype.constructor = createBlockedFunction;
    if (typeof WebSocket !== 'undefined' && WebSocket.prototype) {
      const wsProto = WebSocket.prototype;
      const originalSend = wsProto.send;
      wsProto.send = function (...args) {
        if (this.preventRequests) {
          this.logBlockedRequest('WebSocket Send Blocked', {
            data: args[0]
          });
          return;
        }
        return originalSend.apply(this, args);
      }.bind(this);
      const originalClose = wsProto.close;
      wsProto.close = function (...args) {
        if (this.preventRequests) {
          console.log('WebSocket close prevented');
          return;
        }
        return originalClose.apply(this, args);
      }.bind(this);
    }
    const originalUserInfo = window.getUserInfo;
    if (originalUserInfo) {
      window.getUserInfo = (...args) => {
        if (this.spoofedUsername && this.spoofedUsername.length > 0) {
          const info = originalUserInfo(...args);
          return {
            ...info,
            username: this.spoofedUsername,
            displayName: this.spoofedUsername,
            profile: {
              ...info.profile,
              username: this.spoofedUsername,
              displayName: this.spoofedUsername
            }
          };
        }
        return originalUserInfo(...args);
      };
    }
    if ('Notification' in window) {
      window.Notification.requestPermission = () => Promise.resolve('denied');
    }
    if ('fetch' in window) {
      const origFetch = window.fetch;
      window.fetch = (...args) => {
        if (this.preventRequests) {
          this.logBlockedRequest('Fetch blocked', {
            url: args[0]
          });
          return new Promise(() => {});
        }
        return origFetch.apply(window, args);
      };
    }
    ['localStorage', 'sessionStorage'].forEach(storageName => {
      if (storageName in window) {
        try {
          const origStorage = window[storageName];
          const proxyStorage = new Proxy(origStorage, {
            get: (target, prop) => {
              if (this.preventRequests && ['setItem', 'clear', 'removeItem'].includes(prop)) {
                this.logBlockedRequest('Storage operation blocked', {
                  storage: storageName,
                  method: prop
                });
                return () => {};
              }
              return target[prop];
            }
          });
          try {
            Object.defineProperty(window, storageName, {
              get: () => proxyStorage
            });
          } catch (e) {
            console.warn(`Could not override ${storageName}`, e);
          }
        } catch (e) {
          console.warn(`Error setting up ${storageName} proxy`, e);
        }
      }
    });
  }
  setupProxyTraps() {
    const createProxy = (obj, path = '') => {
      if (obj === null || typeof obj !== 'object' || this.proxyHandlers.has(obj)) {
        return obj;
      }
      const handler = {
        get: (target, prop) => {
          if (prop === 'constructor' || prop === 'prototype' || prop === '__proto__') {
            return target[prop];
          }
          const value = target[prop];
          if (typeof value === 'function' && (prop.toString().includes('send') || prop.toString().includes('request'))) {
            return (...args) => {
              if (this.preventRequests) {
                this.logBlockedRequest('Proxied Method Call Blocked', {
                  path: `${path}.${prop.toString()}`,
                  args
                });
                return;
              }
              return value.apply(target, args);
            };
          }
          return value;
        },
        set: (target, prop, value) => {
          if (this.preventRequests && (prop.toString().includes('onmessage') || prop.toString().includes('onopen'))) {
            this.logBlockedRequest('Event Handler Assignment Blocked', {
              path: `${path}.${prop.toString()}`
            });
            return true;
          }
          target[prop] = value;
          return true;
        }
      };
      const proxied = new Proxy(obj, handler);
      this.proxyHandlers.set(obj, handler);
      return proxied;
    };
    const protosToProxy = [window.WebSocket.prototype, XMLHttpRequest.prototype];
    protosToProxy.forEach(proto => {
      if (!this.interceptedPrototypes.has(proto)) {
        createProxy(proto);
        this.interceptedPrototypes.add(proto);
      }
    });
  }
  setupPeriodicReinforcement() {
    if (this.blockAllTimer) clearInterval(this.blockAllTimer);
    this.blockAllTimer = setInterval(() => {
      if (Date.now() - this.lastInitTime > 5000) {
        this.initialize();
        this.lastInitTime = Date.now();
      }
      const eventExists = !!document.eventListeners?.keydown?.find(l => l.toString().includes('altKey') && l.toString().includes('toggleOverlay'));
      if (!eventExists) {
        document.addEventListener('keydown', e => {
          if (e.altKey && e.key.toLowerCase() === 'g') {
            e.preventDefault();
            this.toggleOverlay();
          }
        });
      }
      if (this.preventRequests) {
        if (window.stop) window.stop();
        const highestId = setTimeout(() => {}, 0);
        for (let i = 0; i < highestId; i++) {
          clearTimeout(i);
          clearInterval(i);
        }
        const wsInstances = Array.from(document.querySelectorAll('*')).filter(el => el.protocol === 'websocket:');
        wsInstances.forEach(ws => {
          try {
            ws.close();
            this.logBlockedRequest('Forced WebSocket Disconnect', {
              url: ws.url
            });
          } catch (e) {}
        });
      }
      this.websimSockets.forEach((socket, socketId) => {
        if (socket.readyState === WebSocket.CLOSED || socket.readyState === WebSocket.CLOSING) {
          this.handleSocketClose(socketId, socket._originalArgs);
        }
      });
    }, 1000);
  }
  setupDatabaseEditor() {
    const databaseEditor = document.querySelector('.database-editor');
    if (!databaseEditor) return;
    let buttonsContainer = databaseEditor.querySelector('.database-editor-buttons');
    if (!buttonsContainer) {
      buttonsContainer = document.createElement('div');
      buttonsContainer.className = 'database-editor-buttons';
      databaseEditor.insertBefore(buttonsContainer, databaseEditor.firstChild);
    } else {
      buttonsContainer.innerHTML = '';
    }
    const buttons = [{
      id: 'create-record',
      text: 'Create Record',
      action: 'create'
    }, {
      id: 'update-record',
      text: 'Update Record',
      action: 'update'
    }, {
      id: 'delete-record',
      text: 'Delete Record',
      action: 'delete'
    }, {
      id: 'get-records',
      text: 'Get Records',
      action: 'get'
    }, {
      id: 'scan-collections',
      text: 'Scan Collections',
      action: 'scan'
    }];
    buttons.forEach(({
      id,
      text,
      action
    }) => {
      const button = document.createElement('button');
      button.id = id;
      button.textContent = text;
      button.addEventListener('click', () => {
        if (action === 'scan') {
          this.scanForCollections();
          this.updateCollectionSelect();
        } else {
          this.handleDatabaseAction(action);
        }
      });
      buttonsContainer.appendChild(button);
    });
    const existingBanners = document.querySelectorAll('.discord-banner');
    existingBanners.forEach((banner, index) => {
      if (index > 0) banner.remove();
    });
  }
  scanForCollections() {
    this.collectionTypes.clear();
    const scriptTags = document.getElementsByTagName('script');
    for (const script of scriptTags) {
      const content = script.textContent || '';
      const patterns = [/collection\(['"](\w+)['"]\)/g, /\.collection\(['"](\w+)['"]\)/g, /collection:\s*['"](\w+)['"]/g, /room\.collection\(['"](\w+)['"]\)/g, /websim\.collection\(['"](\w+)['"]\)/g, /collection\s*=\s*['"](\w+)['"]/g, /collection_type\s*[:=]\s*['"](\w+)['"]/g, /collection:\s*['"]([\w-]+)['"]/g, /collection:\s*{[\s\n]*type:\s*['"]([\w-]+)['"]/g, /collectionName:\s*['"]([\w-]+)['"]/g, /collectionType:\s*['"]([\w-]+)['"]/g, /collection_name:\s*['"]([\w-]+)['"]/g, /\.collection\(['"]([\w-]+)['"]\)/g, /collection\(['"]([\w-]+)['"]\)/g];
      patterns.forEach(pattern => {
        const matches = content.matchAll(pattern);
        for (const match of matches) {
          if (match[1]) {
            this.collectionTypes.add(match[1]);
          }
        }
      });
    }
    const iterator = document.createNodeIterator(document.documentElement, NodeFilter.SHOW_COMMENT);
    let comment;
    while (comment = iterator.nextNode()) {
      const patterns = [/collection['"]\s*:\s*['"](\w+)['"]/g, /collection\(['"](\w+)['"]\)/g];
      patterns.forEach(pattern => {
        const matches = comment.textContent.matchAll(pattern);
        for (const match of matches) {
          if (match[1]) {
            this.collectionTypes.add(match[1]);
          }
        }
      });
    }
    const allElements = document.getElementsByTagName('*');
    for (const el of allElements) {
      for (const attr of el.attributes) {
        const value = attr.value;
        const patterns = [/collection\(['"](\w+)['"]\)/, /collection:\s*['"](\w+)['"]/, /collection\s*=\s*['"](\w+)['"]/, /collection[Nn]ame:\s*['"](\w+)['"]/, /collection[Tt]ype:\s*['"](\w+)['"]/];
        patterns.forEach(pattern => {
          const match = value.match(pattern);
          if (match && match[1]) {
            this.collectionTypes.add(match[1]);
          }
        });
      }
      const content = el.textContent;
      const patterns = [/collection\(['"](\w+)['"]\)/g, /\.collection\(['"](\w+)['"]\)/g, /collection:\s*['"](\w+)['"]/g, /collection[Nn]ame:\s*['"](\w+)['"]/g, /collection[Tt]ype:\s*['"](\w+)['"]/g];
      patterns.forEach(pattern => {
        const matches = content.matchAll(pattern);
        for (const match of matches) {
          if (match[1]) {
            this.collectionTypes.add(match[1]);
          }
        }
      });
    }
    if (this.collectionTypes.size === 0) {
      console.log('No collections found in page source');
    }
  }
  updateCollectionSelect() {
    const collectionSelect = document.getElementById('collection-select');
    if (!collectionSelect) return;
    collectionSelect.innerHTML = '';
    Array.from(this.collectionTypes).sort().forEach(type => {
      const option = document.createElement('option');
      option.value = type;
      option.textContent = type;
      collectionSelect.appendChild(option);
    });
    if (this.collectionTypes.size === 0) {
      const option = document.createElement('option');
      option.value = '';
      option.textContent = 'No collections found - click Scan Collections';
      option.disabled = true;
      option.selected = true;
      collectionSelect.appendChild(option);
    }
  }
  renderRecordsGrid() {
    const recordsList = document.getElementById('records-list');
    if (!recordsList) return;
    const start = this.currentPage * this.recordsPerPage;
    const end = start + this.recordsPerPage;
    const pageRecords = this.currentRecords.slice(start, end);
    const grid = document.createElement('div');
    grid.className = 'records-grid';
    pageRecords.forEach(record => {
      const card = document.createElement('div');
      card.className = 'record-card';
      card.innerHTML = `
        <pre>${JSON.stringify(record, null, 2)}</pre>
        <button class="copy-id-btn" data-id="${record.id}">Copy ID</button>
      `;
      card.addEventListener('click', e => {
        if (!e.target.matches('.copy-id-btn')) {
          document.getElementById('record-data').value = JSON.stringify(record, null, 2);
          document.getElementById('record-id').value = record.id;
        }
      });
      card.querySelector('.copy-id-btn').addEventListener('click', e => {
        e.stopPropagation();
        navigator.clipboard.writeText(record.id);
      });
      grid.appendChild(card);
    });
    const pagination = document.createElement('div');
    pagination.className = 'pagination';
    pagination.innerHTML = `
      <button class="page-btn prev" ${this.currentPage === 0 ? 'disabled' : ''}>Previous</button>
      <button class="page-btn next" ${end >= this.currentRecords.length ? 'disabled' : ''}>Next</button>
    `;
    pagination.querySelector('.prev').addEventListener('click', () => {
      if (this.currentPage > 0) {
        this.currentPage--;
        this.renderRecordsGrid();
      }
    });
    pagination.querySelector('.next').addEventListener('click', () => {
      if ((this.currentPage + 1) * this.recordsPerPage < this.currentRecords.length) {
        this.currentPage++;
        this.renderRecordsGrid();
      }
    });
    recordsList.innerHTML = '';
    recordsList.appendChild(grid);
    recordsList.appendChild(pagination);
  }
  async handleDatabaseAction(action) {
    const collectionName = document.getElementById('collection-select')?.value;
    const recordData = document.getElementById('record-data')?.value;
    const recordId = document.getElementById('record-id')?.value;
    const recordsList = document.getElementById('records-list');
    if (!collectionName) return;
    try {
      const ws = new this.originalWebsimSocket();
      const collection = ws.collection(collectionName);
      switch (action) {
        case 'create':
          if (!recordData) return;
          try {
            const data = JSON.parse(recordData);
            await collection.create(data);
            document.getElementById('record-data').value = '';
            this.updateStatus();
          } catch (e) {
            console.error('Invalid JSON:', e);
          }
          break;
        case 'update':
          if (!recordId || !recordData) return;
          try {
            const data = JSON.parse(recordData);
            await collection.update(recordId, data);
            this.updateStatus();
          } catch (e) {
            console.error('Invalid JSON or update failed:', e);
          }
          break;
        case 'delete':
          if (!recordId) return;
          try {
            await collection.delete(recordId);
            this.updateStatus();
          } catch (e) {
            console.error('Delete failed:', e);
          }
          break;
        case 'get':
          try {
            this.currentRecords = await collection.getList();
            const rawJsonDiv = document.createElement('div');
            rawJsonDiv.className = 'raw-json-display';
            rawJsonDiv.textContent = JSON.stringify(this.currentRecords, null, 2);
            recordsList.innerHTML = '';
            recordsList.appendChild(rawJsonDiv);
            this.updateStatus();
          } catch (e) {
            console.error('Failed to get records:', e);
          }
          break;
      }
    } catch (e) {
      console.error('Database action failed:', e);
    }
  }
  logBlockedRequest(type, data) {
    this.blockedRequests.unshift({
      timestamp: new Date().toISOString(),
      type,
      data
    });
    if (this.blockedRequests.length > this.maxLogSize) {
      this.blockedRequests = this.blockedRequests.slice(0, this.maxLogSize);
    }
    this.updateBlockedRequestsLog();
  }
  updateBlockedRequestsLog() {
    const logElement = document.getElementById('blocked-requests-list');
    if (!logElement) return;
    logElement.innerHTML = '';
    if (this.blockedRequests.length > 0) {
      const clearBtn = document.createElement('button');
      clearBtn.className = 'clear-logs-btn';
      clearBtn.textContent = 'Clear Logs';
      clearBtn.onclick = () => {
        this.blockedRequests = [];
        this.updateBlockedRequestsLog();
      };
      logElement.appendChild(clearBtn);
    }
    this.blockedRequests.forEach(request => {
      const item = document.createElement('div');
      item.className = 'blocked-request-item';
      item.innerHTML = `
        <strong>[${new Date(request.timestamp).toLocaleTimeString()}]</strong>
        ${request.type}: ${JSON.stringify(request.data)}
      `;
      logElement.appendChild(item);
    });
  }
  updateStatus() {
    const status = document.getElementById('fortress-status');
    if (!status) return;
    const statusLines = [`${this.productName} Status: ${this.preventRequests ? 'BLOCKING ALL REQUESTS' : 'Monitoring'}`, this.spoofedUsername ? `Active Username Spoof: ${this.spoofedUsername}` : 'No Username Spoofing', this.spoofedDate ? `Active Date Spoof: ${this.spoofedDate.toLocaleString()}` : 'No Date Spoofing', this.emulateWebsocket ? 'WebSocket Emulation: Active' : 'WebSocket Emulation: Inactive', this.emulateWebsocket ? 'WebsimSocket Emulation: Active' : 'WebsimSocket Emulation: Inactive', `Active WebsimSockets: ${this.websimSockets.size}`, this.websimSockets.size ? `Socket Reconnection Attempts: ${Array.from(this.socketReconnectAttempts.values()).join(', ')}` : '', this.extremeSocketMagic ? 'EXTREME SOCKET MAGIC: Active' : 'EXTREME SOCKET MAGIC: Inactive'];
    if (this.currentRecords.length) {
      statusLines.push(`Current Records: ${this.currentRecords.length}`);
    } else {
      statusLines.push('No records loaded');
    }
    status.innerHTML = statusLines.join('<br>');
    status.style.color = this.preventRequests ? '#ff0000' : '#ffffff';
  }
  toggleOverlay() {
    const overlay = document.getElementById('fortress-overlay');
    if (!overlay) {
      console.error('Fortress overlay not found');
      this.initialize();
      return;
    }
    if (this.lastKeyEvent?.altKey && this.lastKeyEvent?.key?.toLowerCase() === 'g') {
      this.active = !this.active;
      overlay.style.display = this.active ? 'block' : 'none';
    }
  }
  reinforceSpoofing() {
    if (this.spoofCheckInterval) {
      clearInterval(this.spoofCheckInterval);
    }
    this.spoofCheckInterval = setInterval(() => {
      if (this.spoofedUsername) {
        const originalUserInfo = window.getUserInfo;
        if (originalUserInfo) {
          window.getUserInfo = (...args) => {
            const info = originalUserInfo(...args);
            return {
              ...info,
              username: this.spoofedUsername,
              displayName: this.spoofedUsername,
              profile: {
                ...info.profile,
                username: this.spoofedUsername,
                displayName: this.spoofedUsername
              }
            };
          };
        }
        this.initializeWebsimSocketProxy();
        if (window.WebsimSocket) {
          const activeConnections = Array.from(document.querySelectorAll('*')).filter(el => el._websocket).map(el => el._websocket);
          activeConnections.forEach(ws => {
            if (ws.party) {
              Object.defineProperty(ws.party, 'client', {
                get: () => ({
                  ...ws.party.client,
                  username: this.spoofedUsername
                })
              });
              if (ws.party.peers) {
                const clientId = ws.party.client?.id;
                if (clientId) {
                  Object.defineProperty(ws.party, 'peers', {
                    get: () => {
                      const peers = {
                        ...ws.party.peers
                      };
                      if (peers[clientId]) {
                        peers[clientId] = {
                          ...peers[clientId],
                          username: this.spoofedUsername
                        };
                      }
                      return peers;
                    }
                  });
                }
              }
            }
            const originalSend = ws.send;
            ws.send = (...args) => {
              if (args[0] && typeof args[0] === 'object') {
                args[0] = {
                  ...args[0],
                  username: this.spoofedUsername,
                  clientInfo: {
                    ...args[0]?.clientInfo,
                    username: this.spoofedUsername
                  }
                };
              }
              return originalSend.apply(ws, args);
            };
          });
        }
      }
    }, 500);
  }
  enableWebsocketEmulation() {
    if (!this.originalWebSocket) {
      this.originalWebSocket = window.WebSocket;
    }
    const EmulatedWebSocket = function (...args) {
      const realWs = new this.originalWebSocket(...args);
      const ws = Object.create(this.originalWebSocket.prototype);
      this.socketReadyStates.set(ws, WebSocket.CONNECTING);
      realWs.addEventListener('open', () => {
        this.socketReadyStates.set(ws, WebSocket.OPEN);
        if (ws.onopen) ws.onopen();
      });
      realWs.addEventListener('message', event => {
        this.socketReadyStates.set(ws, WebSocket.OPEN);
        if (ws.onmessage) ws.onmessage(event);
      });
      realWs.addEventListener('error', () => {
        if (ws.onerror) ws.onerror();
      });
      realWs.addEventListener('close', () => {
        this.handleSocketClose(ws, args);
        if (ws.onclose) ws.onclose();
      });
      ws.close = function () {
        console.log('Socket close prevented');
        return false;
      };
      const originalSend = realWs.send.bind(realWs);
      ws.send = function (...sendArgs) {
        const state = this.socketReadyStates.get(ws);
        if (state !== WebSocket.OPEN) {
          console.log('Socket not ready, queueing message');
          return false;
        }
        try {
          return originalSend(...sendArgs);
        } catch (e) {
          console.log('Send failed, using emulated send');
          console.log('Intercepted WebSocket message:', ...sendArgs);
          return true;
        }
      }.bind(this);
      ws.collection = function (name) {
        if (realWs.collection) {
          try {
            return realWs.collection(name);
          } catch (e) {
            console.log('Using emulated collection');
          }
        }
        return {
          create: async data => {
            try {
              if (realWs.collection) {
                return await realWs.collection(name).create(data);
              }
            } catch (e) {
              console.log('Using emulated create');
            }
            return {
              id: Math.random().toString(36).substr(2, 9),
              ...data
            };
          },
          update: async (id, data) => {
            try {
              if (realWs.collection) {
                return await realWs.collection(name).update(id, data);
              }
            } catch (e) {
              console.log('Using emulated update');
            }
            return {
              id,
              ...data
            };
          },
          delete: async id => {
            try {
              if (realWs.collection) {
                return await realWs.collection(name).delete(id);
              }
            } catch (e) {
              console.log('Using emulated delete');
            }
            return true;
          },
          getList: async () => {
            try {
              if (realWs.collection) {
                return await realWs.collection(name).getList();
              }
            } catch (e) {
              console.log('Using emulated getList');
            }
            return [];
          },
          filter: query => ({
            getList: async () => {
              try {
                if (realWs.collection) {
                  return await realWs.collection(name).filter(query).getList();
                }
              } catch (e) {
                console.log('Using emulated filter');
              }
              return [];
            },
            subscribe: callback => {
              try {
                if (realWs.collection) {
                  return realWs.collection(name).filter(query).subscribe(callback);
                }
              } catch (e) {
                console.log('Using emulated subscribe');
              }
              callback([]);
              return () => {};
            }
          }),
          subscribe: callback => {
            try {
              if (realWs.collection) {
                return realWs.collection(name).subscribe(callback);
              }
            } catch (e) {
              console.log('Using emulated subscribe');
            }
            callback([]);
            return () => {};
          }
        };
      };
      ws.party = {
        client: realWs.party?.client || {
          id: Math.random().toString(36).substr(2, 9),
          username: this.spoofedUsername || 'emulated_user',
          avatarUrl: `https://images.websim.ai/avatar/${this.spoofedUsername || 'emulated_user'}`
        },
        peers: realWs.party?.peers || {},
        subscribe: callback => {
          if (realWs.party?.subscribe) {
            try {
              return realWs.party.subscribe(callback);
            } catch (e) {
              console.log('Using emulated party subscribe');
            }
          }
          callback({});
          return () => {};
        }
      };
      return ws;
    }.bind(this);
    EmulatedWebSocket.CONNECTING = this.originalWebSocket.CONNECTING;
    EmulatedWebSocket.OPEN = this.originalWebSocket.OPEN;
    EmulatedWebSocket.CLOSING = this.originalWebSocket.CLOSING;
    EmulatedWebSocket.CLOSED = this.originalWebSocket.CLOSED;
    window.WebSocket = EmulatedWebSocket;
    window.WebsimSocket = EmulatedWebSocket;
    this.startSocketHeartbeat();
  }
  handleSocketClose(socketId, originalArgs) {
    const attempts = this.socketReconnectAttempts.get(socketId) || 0;
    if (attempts < this.maxReconnectAttempts || this.extremeSocketMagic) {
      this.pendingReconnects.add(socketId);
      const newSocket = new this.originalWebsimSocket(...originalArgs);
      newSocket._originalArgs = originalArgs;
      this.websimSockets.set(socketId, newSocket);
      this.socketReconnectAttempts.set(socketId, attempts + 1);
      this.socketReadyStates.set(newSocket, WebSocket.CONNECTING);
      newSocket.addEventListener('open', () => {
        console.log(`Socket ${socketId} reconnected successfully`);
        this.pendingReconnects.delete(socketId);
        this.socketReadyStates.set(newSocket, WebSocket.OPEN);
        this.socketReconnectAttempts.set(socketId, 0);
      });
      const tryReconnect = () => {
        try {
          if (newSocket.readyState === WebSocket.CLOSED || newSocket.readyState === WebSocket.CLOSING) {
            console.log(`Attempting reconnection for socket ${socketId}`);
            this.handleSocketClose(socketId, originalArgs);
          }
        } catch (e) {
          console.error(`Failed to reconnect socket ${socketId}:`, e);
        }
      };
      setTimeout(tryReconnect, this.reconnectDelay * Math.pow(1.5, attempts));
      setTimeout(tryReconnect, this.reconnectDelay * Math.pow(2, attempts));
      setTimeout(tryReconnect, this.reconnectDelay * Math.pow(2.5, attempts));
    }
  }
  startSocketHeartbeat() {
    if (this.socketHeartbeatInterval) {
      clearInterval(this.socketHeartbeatInterval);
    }
    this.socketHeartbeatInterval = setInterval(() => {
      this.websimSockets.forEach((socket, id) => {
        const state = this.socketReadyStates.get(socket);
        if (state !== WebSocket.OPEN && !this.pendingReconnects.has(id)) {
          console.log(`Socket ${id} not ready, attempting reconnection`);
          this.handleSocketClose(id, socket._originalArgs);
        }
        try {
          if (state === WebSocket.OPEN) {
            socket.send(JSON.stringify({
              type: 'heartbeat'
            }));
          }
        } catch (e) {
          console.log('Heartbeat failed, attempting reconnection');
          this.handleSocketClose(id, socket._originalArgs);
        }
      });
    }, this.socketHeartbeatDelay);
  }
  setupXSSFinder() {
    const xssFinderButton = document.getElementById('xss-finder-button');
    const xssControls = document.getElementById('xss-finder-controls');
    const xssTargetsSelect = document.getElementById('xss-targets');
    const jsExecutorInput = document.getElementById('js-executor');
    const executeJsButton = document.getElementById('execute-js');
    const executionStatus = document.getElementById('execution-status');
    if (xssFinderButton) {
      xssFinderButton.removeEventListener('click', this.toggleXSSFinder);
      this.toggleXSSFinder = () => {
        if (xssControls.style.display === 'none') {
          this.findXSSVulnerabilities();
          xssControls.style.display = 'block';
        } else {
          xssControls.style.display = 'none';
        }
      };
      xssFinderButton.addEventListener('click', this.toggleXSSFinder);
    }
    if (executeJsButton) {
      executeJsButton.removeEventListener('click', this.executeJSCode);
      this.executeJSCode = this.executeJSCode.bind(this);
      executeJsButton.addEventListener('click', this.executeJSCode);
    }
  }
  executeJSCode() {
    const xssTargetsSelect = document.getElementById('xss-targets');
    const jsExecutorInput = document.getElementById('js-executor');
    const executionStatus = document.getElementById('execution-status');
    if (!xssTargetsSelect || !jsExecutorInput || !executionStatus) {
      return;
    }
    const selectedTarget = xssTargetsSelect.value;
    const jsCode = jsExecutorInput.value;
    if (!selectedTarget || !jsCode) {
      executionStatus.textContent = 'Please select a target and enter JavaScript code.';
      executionStatus.style.color = 'orange';
      return;
    }
    try {
      const targetElement = document.querySelector(`[data-xss-target-id="${selectedTarget}"]`);
      if (!targetElement) {
        executionStatus.textContent = 'Target element not found.';
        executionStatus.style.color = 'orange';
        return;
      }
      const safeEval = new Function('targetElement', `
        try {
          targetElement.value = \`${jsCode}\`;
          targetElement.dispatchEvent(new Event('input', { bubbles: true }));
          return true;
        } catch (e) {
          return e;
        }
      `);
      const result = safeEval(targetElement);
      if (result === true) {
        const submitButton = document.querySelector(`[data-xss-submit-for="${selectedTarget}"]`);
        if (submitButton) {
          submitButton.click();
          if (targetElement.form) {
            targetElement.form.dispatchEvent(new Event('submit'));
          }
          executionStatus.textContent = 'Code executed successfully and submit triggered.';
        } else {
          executionStatus.textContent = 'Code executed successfully (no submit button found).';
        }
        executionStatus.style.color = 'green';
      } else {
        executionStatus.textContent = `Execution failed: ${result.message}`;
        executionStatus.style.color = 'red';
      }
    } catch (error) {
      executionStatus.textContent = `Execution failed: ${error.message}`;
      executionStatus.style.color = 'red';
    }
  }
  updateXSSTargetsUI(targets) {
    const xssTargetsSelect = document.getElementById('xss-targets');
    const placeholderDiv = document.getElementById('target-placeholder');
    if (xssTargetsSelect) {
      xssTargetsSelect.innerHTML = '';
      if (targets.length === 0) {
        const option = document.createElement('option');
        option.value = '';
        option.textContent = 'No targets found';
        xssTargetsSelect.appendChild(option);
      } else {
        targets.forEach(target => {
          const option = document.createElement('option');
          option.value = target.id;
          option.textContent = target.label;
          option.dataset.placeholder = target.placeholder || '';
          xssTargetsSelect.appendChild(option);
        });
      }
      xssTargetsSelect.addEventListener('change', e => {
        const selected = e.target.options[e.target.selectedIndex];
        if (placeholderDiv) {
          const placeholder = selected.dataset.placeholder;
          placeholderDiv.textContent = placeholder ? `Placeholder: "${placeholder}"` : '';
        }
      });
    }
  }
  setupDateSpoof() {
    const dateInput = document.getElementById('date-spoof');
    const timeInput = document.getElementById('time-spoof');
    const activateButton = document.getElementById('activate-date-spoof');
    const resetButton = document.getElementById('reset-date-spoof');
    const spoofStatus = document.getElementById('date-spoof-status');
    if (activateButton) {
      activateButton.removeEventListener('click', this.activateDateSpoofHandler);
      this.activateDateSpoofHandler = () => {
        const date = dateInput.value;
        const time = timeInput.value;
        if (date && time) {
          const newDate = new Date(`${date}T${time}`);
          this.spoofedTimestamp = newDate.getTime();
          this.spoofedDate = newDate;
          if (spoofStatus) {
            spoofStatus.textContent = `Active spoof: ${this.spoofedDate.toLocaleString()}`;
          }
          this.updateStatus();
          this.overrideDateFunctions();
        }
      };
      activateButton.addEventListener('click', this.activateDateSpoofHandler);
    }
    if (resetButton) {
      resetButton.removeEventListener('click', this.resetDateSpoofHandler);
      this.resetDateSpoofHandler = () => {
        this.spoofedDate = null;
        this.spoofedTimestamp = null;
        if (spoofStatus) {
          spoofStatus.textContent = 'Date/Time reset';
        }
        this.updateStatus();
        window.Date = this.originalDate || window.Date;
      };
      resetButton.addEventListener('click', this.resetDateSpoofHandler);
    }
    if (this.dateSpoofInterval) {
      clearInterval(this.dateSpoofInterval);
    }
  }
  findXSSVulnerabilities() {
    const targets = [];
    const contentArea = document.getElementById('fortress-overlay');
    const findSubmitButton = inputElement => {
      if (inputElement.form) {
        const submits = inputElement.form.querySelectorAll('button[type="submit"], input[type="submit"]');
        if (submits.length > 0) return submits[0];
      }
      let element = inputElement;
      for (let i = 0; i < 3; i++) {
        if (!element.parentElement) break;
        element = element.parentElement;
        const buttons = element.querySelectorAll('button, input[type="button"], input[type="submit"]');
        for (const button of buttons) {
          const text = (button.textContent || button.value || '').toLowerCase();
          if (text.match(/send|submit|enter|post|chat/i)) {
            return button;
          }
        }
      }
      return null;
    };
    const scanChunk = (startNode, chunkSize = 1000) => {
      let count = 0;
      const walker = document.createTreeWalker(startNode, NodeFilter.SHOW_ELEMENT, {
        acceptNode: node => {
          if (contentArea.contains(node)) {
            return NodeFilter.FILTER_REJECT;
          }
          if (node.tagName === 'TEXTAREA' || node.tagName === 'INPUT' && node.type === 'text') {
            return NodeFilter.FILTER_ACCEPT;
          }
          return NodeFilter.FILTER_SKIP;
        }
      });
      let node;
      while ((node = walker.nextNode()) && count < chunkSize) {
        const submitButton = findSubmitButton(node);
        const id = `${node.tagName.toLowerCase()}-${targets.length + 1}`;
        node.setAttribute('data-xss-target-id', id);
        if (submitButton) {
          submitButton.setAttribute('data-xss-submit-for', id);
        }
        const placeholder = node.getAttribute('placeholder');
        targets.push({
          id,
          label: `${node.tagName === 'TEXTAREA' ? 'Textarea' : 'Input Field'} - ${node.id || node.name || `at ${node.className || 'unnamed'}`}${submitButton ? ' (Has Submit Button)' : ''}`,
          placeholder: placeholder || ''
        });
        count++;
      }
      if (walker.nextNode()) {
        setTimeout(() => scanChunk(node, chunkSize), 0);
      } else {
        this.updateXSSTargetsUI(targets);
      }
    };
    scanChunk(document.body);
  }
  cleanup() {
    if (this.socketHeartbeatInterval) {
      clearInterval(this.socketHeartbeatInterval);
    }
  }
  enableExtremeSocketMagic() {
    const originalSend = WebSocket.prototype.send;
    WebSocket.prototype.send = function (...args) {
      try {
        const data = JSON.parse(args[0]);
        if (data.type === 'close') {
          console.log('Blocked close socket message');
          return false;
        }
        if (data.type === 'connect') {
          data.userId = this.fakeUserId;
          data.connectionId = Math.random().toString(36).substring(2, 15) + '-' + Math.random().toString(36).substring(2, 15) + '-' + Math.random().toString(36).substring(2, 15) + '-' + Math.random().toString(36).substring(2, 15);
          this.interceptedConnectionIds.set(this, data.connectionId);
          args[0] = JSON.stringify(data);
        }
      } catch (e) {
        if (typeof args[0] === 'string' && args[0].includes('close')) {
          console.log('Blocked raw close socket message');
          return false;
        }
      }
      return originalSend.apply(this, args);
    }.bind(this);
    const originalOnMessage = WebSocket.prototype.onmessage;
    WebSocket.prototype.onmessage = function (event) {
      try {
        const data = JSON.parse(event.data);
        if (data.type === 'close') {
          console.log('Blocked incoming close socket message');
          return;
        }
        if (data.type === 'connected') {
          data.userId = this.fakeUserId;
          data.connectionId = this.interceptedConnectionIds.get(this) || data.connectionId;
          event = new MessageEvent('message', {
            data: JSON.stringify(data)
          });
        }
      } catch (e) {
        if (typeof event.data === 'string' && event.data.includes('close')) {
          console.log('Blocked raw incoming close socket message');
          return;
        }
      }
      return originalOnMessage.call(this, event);
    };
    const originalClose = WebSocket.prototype.close;
    WebSocket.prototype.close = function (...args) {
      console.log('Blocked WebSocket close() call');
      return false;
    };
    this.startExtremeHeartbeat();
  }
  disableExtremeSocketMagic() {
    if (this.extremeHeartbeatInterval) {
      clearInterval(this.extremeHeartbeatInterval);
    }
    WebSocket.prototype.send = this.originalWebSocket.prototype.send;
    WebSocket.prototype.onmessage = this.originalWebSocket.prototype.onmessage;
    WebSocket.prototype.close = this.originalWebSocketClose || this.originalWebSocket.prototype.close;
  }
  startExtremeHeartbeat() {
    if (this.extremeHeartbeatInterval) {
      clearInterval(this.extremeHeartbeatInterval);
    }
    this.extremeHeartbeatInterval = setInterval(() => {
      this.websimSockets.forEach((socket, id) => {
        if (socket.readyState === WebSocket.CLOSED || socket.readyState === WebSocket.CLOSING) {
          console.log(`Extreme magic: Reconnecting socket ${id}`);
          const newSocket = new this.originalWebsimSocket(socket._originalArgs);
          newSocket._originalArgs = socket._originalArgs;
          this.websimSockets.set(id, newSocket);
          if (this.interceptedConnectionIds.has(socket)) {
            const oldConnectionId = this.interceptedConnectionIds.get(socket);
            this.interceptedConnectionIds.set(newSocket, oldConnectionId);
            this.interceptedConnectionIds.delete(socket);
          }
        }
        try {
          socket.send(JSON.stringify({
            type: 'heartbeat',
            userId: this.fakeUserId,
            connectionId: this.interceptedConnectionIds.get(socket)
          }));
        } catch (e) {
          console.log('Extreme heartbeat failed, forcing reconnection');
          this.handleSocketClose(id, socket._originalArgs);
        }
      });
    }, 1000);
  }
}
document.addEventListener('keydown', e => {
  if (e.altKey && e.key.toLowerCase() === 'g') {
    e.preventDefault();
    const fortressPlugin = new FortressPlugin();
    fortressPlugin.lastKeyEvent = e;
    fortressPlugin.toggleOverlay();
  }
});
function setupPersistentEventListeners() {
  if (!window.fortress) {
    setTimeout(setupPersistentEventListeners, 100);
    return;
  }
  const handler = e => {
    if (fortress.active) {
      if (e.target.tagName === 'INPUT' || e.target.tagName === 'TEXTAREA') {
        return true;
      }
      const blockedKeys = ['c', 'v', 'x', 'a', 'F5', 'F11', 'F12', 'Tab', 'r', 's', 'p', 'u', 'i'];
      if (e.ctrlKey && blockedKeys.includes(e.key.toLowerCase()) || e.altKey && blockedKeys.includes(e.key.toLowerCase()) || e.metaKey && blockedKeys.includes(e.key.toLowerCase()) || blockedKeys.includes(e.key)) {
        e.preventDefault();
        e.stopPropagation();
        return false;
      }
    }
  };
  const contextMenuHandler = e => {
    if (fortress.active) {
      e.preventDefault();
      return false;
    }
  };
  document.addEventListener('keydown', handler, true);
  document.addEventListener('contextmenu', contextMenuHandler, true);
}
document.addEventListener('DOMContentLoaded', () => {
  const fortress = new FortressPlugin();
  window.fortress = fortress;
  document.addEventListener('keydown', e => {
    if (e.altKey && e.key.toLowerCase() === 'g') {
      e.preventDefault();
      fortress.toggleOverlay();
    }
  });
  setupPersistentEventListeners();
});</script>

</body></html>